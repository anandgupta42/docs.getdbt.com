---

title: Why you need to differentiate your production and staging environments in dbt Cloud
description: "The bottom line: You should split your Environments in dbt Cloud based on their purposes (e.g. Production and Staging/CI) and mark one environment as Production. This will improve your CI experience and enable you to use dbt Explorer."
slug: differentiate-prod-and-staging-environments

# image: /img/blog/2023-10-31-to-defer-or-to-clone/preview.png

authors: [joel_labes]

tags: [dbt Cloud]
hide_table_of_contents: false

date: 2023-11-06
is_featured: false

---

:::tip The Bottom Line:
You should split your Environments in dbt Cloud based on their purposes (e.g. Production and Staging/CI) and [set one environment as Production](/docs/deploy/deploy-environments#set-as-production-environment-beta). This will improve your CI experience and enable you to use dbt Explorer.
:::

Environmental segmentation has always been an important part of the analytics engineering workflow:

- When developing new models you can [process a smaller subset of your data](/reference/dbt-jinja-functions/target#use-targetname-to-limit-data-in-dev) by using `target.name` or an environment variable.
- By building your production-grade models into [a different schema and database](https://docs.getdbt.com/docs/build/custom-schemas#managing-environments), you can experiment in peace without being worried that your changes will accidentally impact downstream users.
- Using dedicated credentials for production runs, instead of an analytics engineer's individual dev credentials, ensures that things don't break when that long-tenured employee finally hangs up their IDE.

Historically, dbt Cloud insisted upon a separate environment for _Development_, but had no other specific requirements. Most constructs (such as deferral and documentation) relied on a single job, so as long as you didn't have anything more complex than a CI job mixed in with a couple of production jobs, they could coexist inside of a single Environment and everything would more-or-less work out OK.

But as companies' dbt deployments have grown more complex, it doesn't make sense to assume that a single job is enough anymore. We need to exchange a job-oriented strategy for a more mature and scalable environment-centric view of the world.

Environment-level thinking is particularly important for two new features in dbt Cloud: dbt Explorer and the revised CI workflows.

## Understand your project with dbt Explorer

**The old way**: Your dbt docs site was based on a single job's run.

**The new way**: dbt Explorer uses metadata from across every invocation in a defined Production environment to build the richest and most up-to-date understanding of your project.

Because dbt docs could only be updated by a single predetermined job, users who needed their documentation to immediately reflect changes deployed throughout the day (regardless of which job executed them) would find themselves forced to run a dedicated job which did nothing other than run `dbt docs generate` on a regular schedule.

The Discovery API that powers dbt Explorer ingests all metadata generated by any dbt invocation, which means that it can always be up to date with the applied state of your project. However it doesn't make sense for dbt Explorer to show docs based on a PR that hasn't been merged yet.

To avoid this conflation, you need to mark an environment as the Production environment. All runs completed in _that_ environment will contribute to dbt Explorer's, while others will be excluded. (Future versions of Explorer will support environment selection, so that you can preview your documentation changes as well.)

## Run Slimmer CI than ever with environment-level deferral

**The old way**: Slim CI deferred to a single job, and would only detect changes as of its last build time.

**The new way**: Changes are detected regardless of the job they were deployed in, removing false positives and overbuilding of models in CI.

Just like dbt docs, relying on a single job to define your state for comparison purposes leads to a choice between unnecessarily rebuilding models which were deployed by another job, or creating a dedicated job that runs `dbt compile` on repeat to keep on top of all changes.

By using the environment as the arbiter of state, any time a change is made to your Production deployment it will immediately be taken into consideration by subsequent Slim CI runs.

## The easiest way to break apart your jobs

<Lightbox src="/img/blog/2023-11-06-differentiate-prod-and-staging-environments/data-landscape.png" alt="A chart showing the interplay of Data Warehouse, git repo and dbt Cloud project across Dev, CI and Prod environments." title="Your organization's data landscape should separate Dev, CI and Prod environments. To achieve this, configure your data warehouse, git repo and dbt Cloud account as shown above." width="100%"/>

For most projects, changing from a job-centric to environment-centric approach to metadata is straightforward and immediately pays dividends as described above. Assuming that your Staging/CI and Production jobs are currently intermingled, you can extricate them as follows:

1. Create a new dbt Cloud environment called Staging
2. For each job that belongs to the Staging environment, edit the job and update its environment
3. Tick the "Mark as Production environment" box in your original environment's settings
